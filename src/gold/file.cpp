
#include <type_traits>
#include <sparge/gold/file.hpp>
#include <sparge/gold/reader/get_vis.hpp>
#include <boost/locale/encoding.hpp>
#include <boost/format.hpp>
#include <locale>
#include <cassert>

using namespace std;
namespace sparge
{
namespace gold
{

void file::add_property(const property &prop)
{
	switch (prop.index)
	{
	case property::NameIdx:				name 			 = prop.value; break;
	case property::Version:				version			 = prop.value; break;
	case property::Author:				author			 = prop.value; break;
	case property::About:				about			 = prop.value; break;
	case property::Character_Set:		character_set 	 = prop.value; break;
	case property::Character_Mapping:	character_mapping= prop.value; break;
	case property::Generated_Date:		generated_date 	 = prop.value; break;
	case property::Generated_By:		generated_by 	 = prop.value; break;
	}
}


void file::add_record(const record &r )
{
	switch(r.entries.at(0).get<byte>())
	{
	case property::id:
		add_property(property::from_record(r));
		break;
	case table_counts::id:
		this->table_counts = table_counts::from_record(r);
		break;
	case character_set_table::id:
		this->character_set_tables.emplace(character_set_table::from_record(r));
		break;
	case symbol::id:
		this->symbol_table.emplace(symbol::from_record(r));
		break;
	case group_record::id:
		group_records.emplace(group_record::from_record(r));
		break;
	case production::id:
		productions.emplace(production::from_record(r));
		break;
	case initial_states::id:
		initial_states = initial_states::from_record(r);
		break;
	case dfa_state::id:

		dfa_states.emplace(dfa_state::from_record(r));
		break;
	case lalr_state::id:
		lalr_states.emplace(lalr_state::from_record(r));
		break;
	}
}


file read_raw_file(const std::string & rf) {return read_raw_file(raw_file::load_file(rf));}
file read_raw_file(const raw_file & rf)
{
	using namespace std;

	file f;

	f.gold_version = rf.name;

	for (auto &rec : rf.records)
		f.add_record(rec);

	assert(f.symbol_table.size()			== f.table_counts.symbol_table );
	assert(f.character_set_tables.size()	== f.table_counts.set_table    );
	assert(f.productions.size()				== f.table_counts.rule_table   );
	assert(f.dfa_states.size()				== f.table_counts.dfa_table    );
	assert(f.lalr_states.size()				== f.table_counts.lalr_table   );
	assert(f.group_records.size()			== f.table_counts.group_table  );

	return f;
}

std::ostream & operator<<(std::ostream & ostr, const file &f)
{
	auto enc = [](const string & s){return boost::locale::conv::from_utf(s, "utf-8");};

	ostr <<
		boost::format("# Description of %1%\n\n") % enc(f.name) ;

	ostr << "| Header Data | Value |\n"
			"|-------------|-------|\n";

	auto fr = boost::format("| %1% | %2% |\n");

    ostr << fr % "Generated by" % enc(f.generated_by		);
	ostr << fr % "File Version" % enc(f.gold_version 		);
	ostr << fr % "Name" 	 % enc(f.name				);
	ostr << fr % "Version"   % enc(f.version			);
	ostr << fr % "Author" 	 % enc(f.author				);
	ostr << fr % "About" 	 % enc(f.about				);
	ostr << fr % "Character Set" % enc(f.character_set		);
	ostr << fr % "Character Mapping" % enc(f.character_mapping	);
    ostr << fr % "Generated on" % enc(f.generated_date 	);

    ostr << "\n\n";


    ostr << f.table_counts;

    ostr << "\n\n";

	ostr << "| Index | Characters | Ranges |\n"
			"|-------|------------|--------|\n";

    for (auto & cst : f.character_set_tables)
    	ostr << "| " << cst.first << cst.second;


    ostr << "\n\n";
	ostr << "| Index | Type       | Name   |\n"
			"|-------|------------|--------|\n";

	for (auto & sym : f.symbol_table)
		ostr << "| " << sym.first << sym.second;


    ostr << "\n\n## Group Records\n\n";
	for (auto & sym : f.group_records)
		ostr << "### Nr. " << sym.first<< " - " << sym.second;


	ostr << "\n\n## Productions\n\n";
	ostr << "| Index | Head | Symbols |\n"
			"|-------|------|---------|\n";

	for (auto & p : f.productions)
		ostr << "| " << p.first <<  p.second;

	ostr << "\n\n";


	ostr << "## Initial States\n\n" << f.initial_states << "\n";


	ostr << "## DFA Sates\n\n";

	for (auto & l : f.dfa_states)
		ostr << "### D" << l.first << "\n\n" << l.second << "\n";


	ostr << "## LALR Sates\n\n";

	for (auto & l : f.lalr_states)
		ostr << "### L" << l.first << "\n\n" << l.second << "\n";


    return ostr;
}

}
}
